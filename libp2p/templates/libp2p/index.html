{% extends 'base.html' %}
{% load static %}
{% block title %}js-libp2p demo{% endblock %}
{% block sw_url %}{% url "libp2p:sw.js" %}{% endblock %}
{% block container %}
  <header>
    <h1 id="status">Starting libp2p...</h1>
  </header>
  <main>
    <input type="text" id="peer"/><br>
    <textarea id="content"></textarea><textarea id="received" readonly></textarea><br>
    <button type="submit" onclick="
      dailing(
        document.querySelector('#peer').value,
        document.querySelector('#content').value)
    ">say hi</button>
    <ul id="peers"></ul>
  </main>
{% endblock %}
{% block script %}
  <script src="{% static 'libp2p/libp2p.js' %}"></script>
{#  <script src="https://wzrd.in/standalone/libp2p@0.29.3"></script>#}
  <script src="https://wzrd.in/standalone/libp2p-websockets@0.14.0"></script>
  <script src="{% static 'libp2p/webrtc-star.js' %}"></script>
{#  <script src="https://wzrd.in/standalone/libp2p-webrtc-star@0.20.2"></script>#}
  <script src="https://wzrd.in/standalone/libp2p-noise@2.0.1"></script>
  <script src="https://wzrd.in/standalone/libp2p-mplex@0.10.1"></script>
  <script src="https://bundle.run/it-pipe@1.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/peer-id@0.14.2/dist/index.min.js"></script>
  <script type="module">
    import {map, filter, collect, consume} from 'https://cdn.jsdelivr.net/npm/streaming-iterables@5.0.3/dist/index.mjs';

    const country = '/dns4/webrtc-star.dist.pub/tcp/443/wss/p2p-webrtc-star';
    const peers = [];
    const connectionBook = {};
    window.p2pConnectionBook = connectionBook;
    const simplePeerOptions = {
      trickle: true,
      config: {
        iceServers: {{ iceServers|safe }},
      }
    };

    function log(txt) {
      console.info(txt);
      const $output = document.querySelector('#received');
      $output.value = `${$output.value}\n${txt}`;
    }

    function getIdHomeByConnection(connection) {
      const id = connection.remotePeer.toB58String();
      const home = connection.remoteAddr ? connection.remoteAddr.toString() : null;
      return [id, home]
    }

    async function getConnectionByPeerId(id) {
      if (connectionBook.hasOwnProperty(id)) {
        return connectionBook[id];
      }
      const connection = await p2pNode.dial(PeerId.createFromB58String(id), {
        spOptions: simplePeerOptions
      });
      connectionBook[id] = connection;
      return connection;
    }

    async function ping(my, address) {
      const latency = await my.ping(address);
      log(`I'm ${latency}ms away by ping from the home ${address}`);
    }

    (async () => {
      const my = await libp2p.create({
        addresses: {
          listen: [country]
        },
        modules: {
          transport: [window.libp2pWebsockets, window.libp2pWebrtcStar],
          connEncryption: [window.libp2pNoise.NOISE],
          streamMuxer: [window.libp2pMplex],
        },
        config: {
          peerDiscovery: {
            autoDial: false,
          },
          transport: {
            WebRTCStar: {
              listenerOptions: simplePeerOptions
            }
          }
        }
      });
      window.p2pNode = my;

      // event
      my.on('error', (error) => log(error));
      my.on('peer:discovery', (peerId) => {
        const id = peerId.toB58String();
        log(`* Nice to meet ${id}`);

        if (!peers.includes(id)) {
          const $li = document.createElement('li');
          $li.innerText = id;
          document.querySelector('#peers').appendChild($li);
        }
      });
      my.connectionManager.on('peer:connect', (connection) => {
        const [id, home] = getIdHomeByConnection(connection);
        const flag = connection.stat.direction === 'outbound' ? '>>' : '<<';

        log(`+${flag}[${connection.id}] meet ${home ? 'person' : id} at ${home || 'somewhere'}`);

        ping(my, connection.remotePeer);
      });
      my.connectionManager.on('peer:disconnect', (connection) => {
        const id = connection.remotePeer.toB58String();
        delete connectionBook[id];
        log(`- Good Bye to ${id}`);
      });

      await my.start();
      const id = my.peerId.toB58String();
      const home = `${country}/p2p/${id}`;
      log(`My home: ${home}`);

      // logic
      document.getElementById('status').innerText = `libp2p started!\n${id}`;

      function transform(connection, stream) {
        return (msg) => {
          log(`[${connection.id}][${stream.id}][request]<< ${msg}`);
          return `transform msg: ${msg}`;
        }
      }

      my.handle('/echo', async ({connection, stream}) => {
        // handle request and send response
        await itPipe(
          stream.source,
          (source) => map(decode, source),
          (source) => map(transform(connection, stream), source),
          (source) => map(encode, source),
          stream.sink,
        );

        // push more message
        const remotePeerId = connection.remotePeer.toB58String();
        const contents = ['hello client', `this is push from ${id}`];

        const anotherConn = await getConnectionByPeerId(remotePeerId);
        const anotherStream = await getStreamByConnectionProtocol(anotherConn, '/print');

        log(`[${anotherConn.id}][${anotherStream.id}][request]>> ${contents.join(', ')}`);
        const results = await itPipe(
          contents,
          (source) => map(encode, source),
          anotherStream,
          consume,
        );
        log(`[${anotherConn.id}][${anotherStream.id}][response]<< ${results}`);
      });

      my.handle('/print', async ({connection, stream}) => {
        // only handle no response
        await itPipe(
          stream.source,
          (source) => map(decode, source),
          filter((msg) => {
            log(`[${connection.id}][${stream.id}][request]<< ${msg}`);
            return false;
          }),
          stream.sink,
        );
      });
    })();

    async function getStreamByConnectionProtocol(connection, protocol) {
      let stream = await connection.newStream(protocol);
      stream = await stream.stream;
      return stream;
    }

    function encode(msg) {
      return encodeURI(msg);
    }

    function decode(msg) {
      return decodeURI(msg);
    }

    window.dailing = async function (peerId, content) {
      const connection = await getConnectionByPeerId(peerId);
      const stream = await getStreamByConnectionProtocol(connection, '/echo');

      log(`[${connection.id}][${stream.id}][request]>> ${content}`);
      const results = await itPipe(
        [content],
        (source) => map(encode, source),
        stream,
        (source) => map(decode, source),
        collect,
      );
      log(`[${connection.id}][${stream.id}][response]<< ${results}`);
    }
  </script>
{% endblock %}
