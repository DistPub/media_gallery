{% extends 'base.html' %}
{% load static %}
{% block title %}js-libp2p demo{% endblock %}
{% block sw_url %}{% url "libp2p:sw.js" %}{% endblock %}
{% block style %}
  <style type="text/css">
    section.main {
      display: flex;
      flex-direction: column;
      height: 100%;
      padding: 1em 0 1em 0;
    }
    main.stage {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      overflow: auto;
    }
    footer.ui.input {
      display: flex;
    }
    #shell {
      flex-grow: 1;
    }
  </style>
{% endblock %}
{% block container %}
  {% include 'includes/modal.html' %}
  {% include 'includes/modal.module' %}
  <script type="module">
    window.showModal('Login', 'Starting libp2p...', false)
  </script>

  <section class="main">
    <header class="ui pointing menu">
      <div class="ui simple dropdown item">
        <i class="add icon"></i> New Chat
        <i class="dropdown icon"></i>
        <div class="menu" id="peers">
        </div>
      </div>
      <a class="item">
        User A
      </a>
      <a class="item active">
        User B
      </a>
      <div class="right menu">
        <div class="item">
          <div class="ui disabled transparent icon input">
            <input type="text" placeholder="Search...">
            <i class="search link icon"></i>
          </div>
        </div>
        <a class="ui item">
          Logout
        </a>
      </div>
    </header>

    <main class="stage">
    </main>


    <footer class="ui action input">
      <div class="ui compact menu">
        <div class="ui simple dropdown item">
          <span class="text">Echo</span>
          <i class="dropdown icon"></i>
          <div class="menu">
            <div class="item">Echo</div>
          </div>
        </div>
      </div>
      <input id="shell" type="text" placeholder="text...">
      <div class="ui primary button" onclick="sendText()">Send</div>
    </footer>
  </section>
  <section id="template" style="display: none">
    <div class="ui feed template">
      <div class="event">
        <div class="label">
          <img src="/images/avatar/small/jenny.jpg">
        </div>
        <div class="content">
          <div class="date">
            3 days ago
          </div>
          <div class="summary">

          </div>
        </div>
      </div>
    </div>
  </section>
{% endblock %}
{% block script %}
  <script src="{% static 'libp2p/libp2p.js' %}"></script>
{#  <script src="https://wzrd.in/standalone/libp2p@0.29.3"></script>#}
  <script src="https://wzrd.in/standalone/libp2p-websockets@0.14.0"></script>
  <script src="{% static 'libp2p/webrtc-star.js' %}"></script>
{#  <script src="https://wzrd.in/standalone/libp2p-webrtc-star@0.20.2"></script>#}
  <script src="https://wzrd.in/standalone/libp2p-noise@2.0.1"></script>
  <script src="https://wzrd.in/standalone/libp2p-mplex@0.10.1"></script>
  <script src="https://bundle.run/it-pipe@1.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/peer-id@0.14.2/dist/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react@17.0.1/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@17.0.1/umd/react-dom.production.min.js"></script>
  <script type="module">
    import {map, filter, collect, consume} from 'https://cdn.jsdelivr.net/npm/streaming-iterables@5.0.3/dist/index.mjs';

    const country = '/dns4/webrtc-star.dist.pub/tcp/443/wss/p2p-webrtc-star';
    const peers = [];
    const connectionBook = {};
    window.p2pConnectionBook = connectionBook;
    const simplePeerOptions = {
      trickle: true,
      config: {
        iceServers: {{ iceServers|safe }},
      }
    };

    function log(txt) {
      console.info(txt);
    }

    function getIdHomeByConnection(connection) {
      const id = connection.remotePeer.toB58String();
      const home = connection.remoteAddr ? connection.remoteAddr.toString() : null;
      return [id, home]
    }

    async function getConnectionByPeerId(id) {
      if (connectionBook.hasOwnProperty(id)) {
        return connectionBook[id];
      }
      const connection = await p2pNode.dial(PeerId.createFromB58String(id), {
        spOptions: simplePeerOptions
      });
      connectionBook[id] = connection;
      return connection;
    }

    async function ping(my, address) {
      const latency = await my.ping(address);
      log(`I'm ${latency}ms away by ping from the home ${address}`);
    }

    (async () => {
      const my = await libp2p.create({
        addresses: {
          listen: [country]
        },
        modules: {
          transport: [window.libp2pWebsockets, window.libp2pWebrtcStar],
          connEncryption: [window.libp2pNoise.NOISE],
          streamMuxer: [window.libp2pMplex],
        },
        config: {
          peerDiscovery: {
            autoDial: false,
          },
          transport: {
            WebRTCStar: {
              listenerOptions: simplePeerOptions
            }
          }
        }
      });
      window.p2pNode = my;

      // event
      my.on('error', (error) => log(error));
      my.on('peer:discovery', (peerId) => {
        const id = peerId.toB58String();
        log(`* Nice to meet ${id}`);

        if (!peers.includes(id)) {
          const $li = document.createElement('div');
          $li.classList.add('item');
          $li.innerText = id;
          $li.onclick = () => openChat(id);
          document.querySelector('#peers').appendChild($li);
        }
      });
      function openChat(id) {
        document.querySelector('.active').classList.remove('active');
        const nav = document.createElement('a');
        nav.classList.add('item', 'active');
        nav.innerText = id;
        const target = document.querySelector('.right.menu');
        target.parentNode.insertBefore(nav, target);
      }
      my.connectionManager.on('peer:connect', (connection) => {
        const [id, home] = getIdHomeByConnection(connection);
        const flag = connection.stat.direction === 'outbound' ? '>>' : '<<';

        log(`+${flag}[${connection.id}] meet ${home ? 'person' : id} at ${home || 'somewhere'}`);

        ping(my, connection.remotePeer);
      });
      my.connectionManager.on('peer:disconnect', (connection) => {
        const id = connection.remotePeer.toB58String();
        delete connectionBook[id];
        log(`- Good Bye to ${id}`);
      });

      await my.start();
      hideModal();
      const id = my.peerId.toB58String();
      const home = `${country}/p2p/${id}`;
      log(`My home: ${home}`);

      // logic
      function transform(connection, stream) {
        return (msg) => {
          renderMessage(msg);
          log(`[${connection.id}][${stream.id}][request]<< ${msg}`);
          return `transform msg: ${msg}`;
        }
      }

      my.handle('/echo', async ({connection, stream}) => {
        // handle request and send response
        await itPipe(
          stream.source,
          (source) => map(decode, source),
          (source) => map(transform(connection, stream), source),
          (source) => map(encode, source),
          stream.sink,
        );

        // push more message
        const remotePeerId = connection.remotePeer.toB58String();
        const contents = ['hello client', `this is push from ${id}`];

        const anotherConn = await getConnectionByPeerId(remotePeerId);
        const anotherStream = await getStreamByConnectionProtocol(anotherConn, '/print');

        log(`[${anotherConn.id}][${anotherStream.id}][request]>> ${contents.join(', ')}`);
        const results = await itPipe(
          contents,
          (source) => map(encode, source),
          anotherStream,
          consume,
        );
        log(`[${anotherConn.id}][${anotherStream.id}][response]<< ${results}`);
      });

      my.handle('/print', async ({connection, stream}) => {
        // only handle no response
        await itPipe(
          stream.source,
          (source) => map(decode, source),
          filter((msg) => {
            renderMessage(msg);
            log(`[${connection.id}][${stream.id}][request]<< ${msg}`);
            return false;
          }),
          stream.sink,
        );
      });
    })();

    async function getStreamByConnectionProtocol(connection, protocol) {
      let stream = await connection.newStream(protocol);
      stream = await stream.stream;
      return stream;
    }

    function encode(msg) {
      return encodeURI(msg);
    }

    function decode(msg) {
      return decodeURI(msg);
    }

    window.sendText = async function () {
      const shell = document.querySelector('#shell');
      const context = shell.value;
      await window.dailing(document.querySelector('.active').innerText, context);
      renderMessage(context);
      shell.value = '';
    };

    window.renderMessage = function (content) {
      const item = document.querySelector('.ui.feed.template').cloneNode(true);
      item.querySelector('.summary').innerText = content;
      document.querySelector('.stage').appendChild(item);
    };

    window.dailing = async function (peerId, content) {
      const connection = await getConnectionByPeerId(peerId);
      const stream = await getStreamByConnectionProtocol(connection, '/echo');

      log(`[${connection.id}][${stream.id}][request]>> ${content}`);
      const results = await itPipe(
        [content],
        (source) => map(encode, source),
        stream,
        (source) => map(decode, source),
        collect,
      );
      log(`[${connection.id}][${stream.id}][response]<< ${results}`);
    }
  </script>
{% endblock %}
