{% extends 'base.html' %}
{% block title %}js-libp2p demo{% endblock %}
{% block sw_url %}{% url "libp2p:sw.js" %}{% endblock %}
{% block container %}
  <header>
    <h1 id="status">Starting libp2p...</h1>
  </header>
  <main>
    <input type="text" id="peer"/>
    <input type="text" id="content"/>
    <button type="submit" onclick="
      dailing(
        document.querySelector('#peer').value,
        document.querySelector('#content').value)
    ">say hi</button>
  </main>
{% endblock %}
{% block script %}
  <script src="https://wzrd.in/standalone/libp2p@0.29.3"></script>
  <script src="https://wzrd.in/standalone/libp2p-websockets@0.14.0"></script>
  <script src="https://wzrd.in/standalone/libp2p-webrtc-star@0.20.1"></script>
  <script src="https://wzrd.in/standalone/libp2p-noise@2.0.1"></script>
  <script src="https://wzrd.in/standalone/libp2p-mplex@0.10.1"></script>
  <script src="https://bundle.run/it-pipe@1.1.0"></script>
  <script type="module">
    import {map,filter,collect,consume} from 'https://cdn.jsdelivr.net/npm/streaming-iterables@5.0.3/dist/index.mjs';

    const country = '/dns4/webrtc-star.dist.pub/tcp/443/wss/p2p-webrtc-star';
    const addressBook = {};
    const connectionBook = {};
    window.p2pAddressBook = addressBook;
    window.p2pConnectionBook = connectionBook;

    function log(txt) {
      console.info(txt);
    }
    function getIdHomeByConnection(connection) {
      const id = connection.remotePeer.toB58String();
      const home = connection.remoteAddr ? connection.remoteAddr.toString() : null;
      return [id, home]
    }
    async function getConnectionByPeerId(id) {
      if (connectionBook.hasOwnProperty(id)) {
        return connectionBook[id];
      }

      let address;
      if (addressBook.hasOwnProperty(id)) {
        address = addressBook[id];
      } else {
        address = `${country}/p2p/${id}`;
      }
      const connection = await p2pNode.dial(address);
      connectionBook[id] = connection;
      return connection;
    }

    async function ping(my, address) {
      const latency = await my.ping(address);
      log(`I'm ${latency}ms away by ping from the home ${address}`);
    }

    (async () => {
      const my = await libp2p.create({
        addresses: {
          listen: [country]
        },
        modules: {
          transport: [window.libp2pWebsockets, window.libp2pWebrtcStar],
          connEncryption: [window.libp2pNoise.NOISE],
          streamMuxer: [window.libp2pMplex],
        },
      });
      window.p2pNode = my;

      // event
      my.on('peer:discovery', (peerId) => {
        log(`* Nice to meet ${peerId.toB58String()}`);
      });
      my.connectionManager.on('peer:connect', (connection) => {
        const [id, home] = getIdHomeByConnection(connection);
        const flag = connection.stat.direction === 'outbound' ? '>>' : '<<';

        log(`+${flag}[${connection.id}] meet ${home ? 'person' : id} at ${home || 'somewhere'}`);

        if (home) {
          addressBook[id] = home;
          ping(my, home);
        }
      });
      my.connectionManager.on('peer:disconnect', (connection) => {
        const id = connection.remotePeer.toB58String();
        delete connectionBook[id];
        log(`- Good Bye to ${id}`);
        delete addressBook[id];
      });

      await my.start();
      const id = my.peerId.toB58String();
      const home = `${country}/p2p/${id}`;
      log(`My home: ${home}`);
      addressBook[id] = home;

      // logic
      document.getElementById('status').innerText = `libp2p started!: ${id}`;

      function transform(connection, stream) {
        return (msg) => {
          log(`[${connection.id}][${stream.id}][request]<< ${msg}`);
          return `transform msg: ${msg}`;
        }
      }

      my.handle('/echo', async ({connection, stream}) => {
        // handle request and send response
        await itPipe(
          stream.source,
          (source) => map(decode, source),
          (source) => map(transform(connection, stream), source),
          (source) => map(encode, source),
          stream.sink,
        );

        // push more message
        const remotePeerId = connection.remotePeer.toB58String();
        const contents = ['hello client', `this is push from ${id}`];

        const anotherConn = await getConnectionByPeerId(remotePeerId);
        const anotherStream = await getStreamByConnectionProtocol(anotherConn, '/print');

        log(`[${anotherConn.id}][${anotherStream.id}][request]>> ${contents.join(', ')}`);
        const results = await itPipe(
          contents,
          (source) => map(encode, source),
          anotherStream,
          consume,
        );
        log(`[${anotherConn.id}][${anotherStream.id}][response]<< ${results}`);
      });

      my.handle('/print', async ({connection, stream}) => {
        // only handle no response
        await itPipe(
          stream.source,
          (source) => map(decode, source),
          filter((msg) => {
            log(`[${connection.id}][${stream.id}][request]<< ${msg}`);
            return false;
          }),
          stream.sink,
        );
      });
    })();

    async function getStreamByConnectionProtocol(connection, protocol) {
      let stream = await connection.newStream(protocol);
      stream = await stream.stream;
      return stream;
    }

    function encode(msg) {
      return encodeURI(msg);
    }

    function decode(msg) {
      return decodeURI(msg);
    }

    window.dailing = async function (peerId, content) {
      const connection = await getConnectionByPeerId(peerId);
      const stream = await getStreamByConnectionProtocol(connection, '/echo');

      log(`[${connection.id}][${stream.id}][request]>> ${content}`);
      const results = await itPipe(
        [content],
        (source) => map(encode, source),
        stream,
        (source) => map(decode, source),
        collect,
      );
      log(`[${connection.id}][${stream.id}][response]<< ${results}`);
    }
  </script>
{% endblock %}
